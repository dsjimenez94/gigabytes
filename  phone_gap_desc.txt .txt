First Java plugin.cordova-plugin-vibrationhttps://github.com/apache/cordova-plugin-vibration/blob/5adf530d3663226ad6913de6cfc8493672334023/src/android/Vibration.javathe if statement say that public boolean execute (when its true or false) (string action, JSONArray args, CallbackContext callbackContext) throws JSONException {if (action.equals(“vibrate’)) {this.vibrate(args.getLong(0)): }so it says  if the action equals to vibrate, it will vibrate else if (action.equals(“vibrateWithPattern”)) {JSONArray pattern = args.getJSONArray(0);int repeat = args.getInt(1);long [] patternArray = new long [pattern.length()+1];patternArray[0] = 0;for (int i = 0; i < pattern.length(); i++ {patternArray[i+1]=pattern.getLong (i);}this says if the action equals to vibrate with pattern, it will repeat. the long pattern array, meaning the vibrate with pattern, the amount of length is not shown, but its added by 1. so i assume its specifying the length of the patterned vibrate. this.vibrateWithPattern(patternArray, repeat);}else if (action.equals(“cancelVibration”)){this.cancelVibration();}else{return false;}callbackContext.success.();return true; (it will only alert and confirm when they are in sync.)}action is to executeargs. JSONArray of arguements for the plugin. callbackContext The call back context use when calling back into Javareturn means True when the action is valid, false otherwise. public void vibrate(long time) {if (time == 0) {time = 500;}vibrator vibrator = (vibrator) this.cordova.getActivity().getSystemService(Context.VIBRATOR_SERVICE);vibrator.vibrate(time);}this helps the device vibrate with a given pattern. public void vibrateWithPattern(long [] pattern, int repeat) {Vibrator vibrator = (Vibrator) this.cordova.getActiity().getSystemService(Context.VIBRATOR_SERVICE);vibrator.vibrate(pattern, repeat);}public void, cancel vibration () {vibrator vibrator = (Vibrator) this.cordova.getActivity().getSystemService(Context.VIBRATOR_SERVICE);vibrator.cancel();	}}so this will immediately cancel any currently running vibration. Second PLuginpackage nl.xservices.plugins;		import android.app.Activity;	import android.content.ContentResolver;	import android.content.Intent;	import android.os.Build;	import android.util.Log;	import nl.xservices.plugins.accessor.AbstractCalendarAccessor;	import nl.xservices.plugins.accessor.CalendarProviderAccessor;	import nl.xservices.plugins.accessor.LegacyCalendarAccessor;	import android.database.Cursor;	import android.net.Uri;		import org.apache.cordova.CallbackContext;	import org.apache.cordova.CordovaPlugin;	import org.apache.cordova.PluginResult;	import org.json.JSONArray;	import org.json.JSONException;	import org.json.JSONObject;		import java.util.Date;public class Calendar extends CordovaPlugin {	"  public static final String ACTION_CREATE_EVENT_WITH_OPTIONS = ""createEventWithOptions"";"	"  public static final String ACTION_CREATE_EVENT_INTERACTIVELY = ""createEventInteractively"";"	"  public static final String ACTION_DELETE_EVENT = ""deleteEvent"";"	"  public static final String ACTION_FIND_EVENT = ""findEvent"";"	"  public static final String ACTION_LIST_EVENTS_IN_RANGE = ""listEventsInRange"";"	"  public static final String ACTION_LIST_CALENDARS = ""listCalendars"";"	"  public static final String ACTION_CREATE_CALENDAR = ""createCalendar"";"public static final Integer RESULT_CODE_CREATE = 0;		  private CallbackContext callback;		  private static final String LOG_TAG = AbstractCalendarAccessor.LOG_TAG;@Override	  public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException {	    callback = callbackContext;	    // TODO this plugin may work fine on 3.0 devices, but have not tested it yet, so to be sure:	    final boolean hasLimitedSupport = Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH;	    if (ACTION_CREATE_EVENT_WITH_OPTIONS.equals(action)) {	      if (hasLimitedSupport) {	        // TODO investigate this option some day: http://stackoverflow.com/questions/3721963/how-to-add-calendar-events-in-android	        return createEventInteractively(args);	      } else {	        return createEvent(args);	      }	    } else if (ACTION_CREATE_EVENT_INTERACTIVELY.equals(action)) {	      return createEventInteractively(args);	    } else if (ACTION_LIST_EVENTS_IN_RANGE.equals(action)) {	      return listEventsInRange(args);	    } else if (!hasLimitedSupport && ACTION_FIND_EVENT.equals(action)) {	      return findEvents(args);	    } else if (!hasLimitedSupport && ACTION_DELETE_EVENT.equals(action)) {	      return deleteEvent(args);	    } else if (ACTION_LIST_CALENDARS.equals(action)) {	      return listCalendars();	//    } else if (!hasLimitedSupport && ACTION_CREATE_CALENDAR.equals(action)) {	//      return createCalendar(args);so its explains that if its true or false, it will display string actions, arguements, callbca context.the final true or false, if the if statement is true, it will create an event interactively, if its not true, it will create an event. else if is the options in creating the event. creating an event interactively listing events in rangefinding eventsdeleting eventsand listing calandars.  return false;	  }	""	  private boolean listCalendars() throws JSONException {	    final JSONArray jsonObject = getCalendarAccessor().getActiveCalendars();	    PluginResult res = new PluginResult(PluginResult.Status.OK, jsonObject);	    callback.sendPluginResult(res);	    return true;	  }	""	  // note: not quite ready for primetime yet	  private boolean createCalendar(JSONArray args) {	    if (args.length() == 0) {	"      System.err.println(""Exception: No Arguments passed"");"	    } else {	      try {	        JSONObject jsonFilter = args.getJSONObject(0);	"        final String calendarName = jsonFilter.getString(""calendarName"");"	""	        getCalendarAccessor().createCalendar(calendarName);	""	"        PluginResult res = new PluginResult(PluginResult.Status.OK, ""yes"");"	        res.setKeepCallback(true);	        callback.sendPluginResult(res);	        return true;	      } catch (JSONException e) {	"        System.err.println(""Exception: "" + e.getMessage());"	      }	    }	    return false;	  }private boolean createEventInteractively(JSONArray args) throws JSONException {	    final JSONObject jsonFilter = args.getJSONObject(0);	""	    final Intent calIntent = new Intent(Intent.ACTION_EDIT)	"        .setType(""vnd.android.cursor.item/event"")"	"        .putExtra(""title"", jsonFilter.optString(""title""))"	"        .putExtra(""beginTime"", jsonFilter.optLong(""startTime""))"	"        .putExtra(""endTime"", jsonFilter.optLong(""endTime""))"	"        .putExtra(""hasAlarm"", 1)"	"        .putExtra(""allDay"", AbstractCalendarAccessor.isAllDayEvent(new Date(jsonFilter.optLong(""startTime"")), new Date(jsonFilter.optLong(""endTime""))));"	    // TODO can we pass a reminder here?	""	    // optional fields	"    if (!jsonFilter.isNull(""location"")) {"	"      calIntent.putExtra(""eventLocation"", jsonFilter.optString(""location""));"	    }	"    if (!jsonFilter.isNull(""notes"")) {"	"      calIntent.putExtra(""description"", jsonFilter.optString(""notes""));"	    }	""	    this.cordova.startActivityForResult(this, calIntent, RESULT_CODE_CREATE);	    return true;	  }	""	  private AbstractCalendarAccessor calendarAccessor;	""	  private AbstractCalendarAccessor getCalendarAccessor() {	    if (this.calendarAccessor == null) {	      // Note: currently LegacyCalendarAccessor is never used, see the TODO at the top of this class	      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {	"        Log.d(LOG_TAG, ""Initializing calendar plugin"");"	        this.calendarAccessor = new CalendarProviderAccessor(this.cordova);	      } else {	"        Log.d(LOG_TAG, ""Initializing legacy calendar plugin"");"	        this.calendarAccessor = new LegacyCalendarAccessor(this.cordova);	      }	    }	    return this.calendarAccessor;	  }in final Intent calIntent it will set Type and put in extra features. lik a title, a start and end time, it has a notifiction alarmand the event is notified all day. you can also add event location and description of that even but it will happen is the statement is true. private boolean deleteEvent(JSONArray args) {	    if (args.length() == 0) {	"      System.err.println(""Exception: No Arguments passed"");"	    } else {	      try {	        JSONObject jsonFilter = args.getJSONObject(0);	        boolean deleteResult = getCalendarAccessor().deleteEvent(	            null,	"            jsonFilter.optLong(""startTime""),"	"            jsonFilter.optLong(""endTime""),"	"            jsonFilter.optString(""title""),"	"            jsonFilter.optString(""location""));"	        PluginResult res = new PluginResult(PluginResult.Status.OK, deleteResult);	        res.setKeepCallback(true);	        callback.sendPluginResult(res);	        return true;	      } catch (JSONException e) {	"        System.err.println(""Exception: "" + e.getMessage());"	      }	    }	    return false;	  }	""	  private boolean findEvents(JSONArray args) {	    if (args.length() == 0) {	"      System.err.println(""Exception: No Arguments passed"");"	    }	    try {	      JSONObject jsonFilter = args.getJSONObject(0);	      JSONArray jsonEvents = getCalendarAccessor().findEvents(	"          jsonFilter.optString(""title""),"	"          jsonFilter.optString(""location""),"	"          jsonFilter.optLong(""startTime""),"	"          jsonFilter.optLong(""endTime""));"	""	      PluginResult res = new PluginResult(PluginResult.Status.OK, jsonEvents);	      res.setKeepCallback(true);	      callback.sendPluginResult(res);	      return true;	""	    } catch (JSONException e) {	"      System.err.println(""Exception: "" + e.getMessage());"	    }	    return false;	  }	""	  private boolean createEvent(JSONArray args) {	    try {	      final JSONObject argObject = args.getJSONObject(0);	"      final JSONObject argOptionsObject = argObject.getJSONObject(""options"");"	""	      boolean status = getCalendarAccessor().createEvent(	          null,	"          argObject.getString(""title""),"	"          argObject.getLong(""startTime""),"	"          argObject.getLong(""endTime""),"	"          argObject.isNull(""notes"") ? null : argObject.getString(""notes""),"	"          argObject.isNull(""location"") ? null : argObject.getString(""location""),"	"          argOptionsObject.isNull(""firstReminderMinutes"") ? null : argOptionsObject.getLong(""firstReminderMinutes""),"	"          argOptionsObject.isNull(""secondReminderMinutes"") ? null : argOptionsObject.getLong(""secondReminderMinutes""),"	"          argOptionsObject.isNull(""recurrence"") ? null : argOptionsObject.getString(""recurrence""),"	"          argOptionsObject.isNull(""recurrenceEndTime"") ? null : argOptionsObject.getLong(""recurrenceEndTime"")"	      );	""	"      callback.success("""" + status);"	      return true;	    } catch (Exception e) {	"      System.err.println(""Exception: "" + e.getMessage());"	    }	    return false;	  }	""	  private boolean listEventsInRange(JSONArray args) {	    try {	      Uri l_eventUri;	      if (Build.VERSION.SDK_INT >= 8) {	"        l_eventUri = Uri.parse(""content://com.android.calendar/events"");"	      } else {	"        l_eventUri = Uri.parse(""content://calendar/events"");"	      }	      ContentResolver contentResolver = this.cordova.getActivity().getContentResolver();	      JSONObject jsonFilter = args.getJSONObject(0);	      JSONArray result = new JSONArray();	"      long input_start_date = jsonFilter.optLong(""startTime"");"	"      long input_end_date = jsonFilter.optLong(""endTime"");"	""	      //prepare start date	      java.util.Calendar calendar_start = java.util.Calendar.getInstance();	      Date date_start = new Date(input_start_date);	      calendar_start.setTime(date_start);	""	      //prepare end date	      java.util.Calendar calendar_end = java.util.Calendar.getInstance();	      Date date_end = new Date(input_end_date);	      calendar_end.setTime(date_end);	""	      //projection of DB columns	"      String[] l_projection = new String[]{""calendar_id"", ""title"", ""dtstart"", ""dtend"", ""eventLocation"", ""allDay""};"	""	      //actual query	"      Cursor cursor = contentResolver.query(l_eventUri, l_projection, ""( dtstart >"" + calendar_start.getTimeInMillis() + "" AND dtend <"" + calendar_end.getTimeInMillis() + "")"", null, ""dtstart ASC"");"	""	      int i = 0;	      while (cursor.moveToNext()) {	        result.put(	            i++,	            new JSONObject()	"                .put(""calendar_id"", cursor.getString(cursor.getColumnIndex(""calendar_id"")))"	"                .put(""title"", cursor.getString(cursor.getColumnIndex(""title"")))"	"                .put(""dtstart"", cursor.getLong(cursor.getColumnIndex(""dtstart"")))"	"                .put(""dtend"", cursor.getLong(cursor.getColumnIndex(""dtend"")))"	"                .put(""eventLocation"", cursor.getString(cursor.getColumnIndex(""eventLocation"")) != null ? cursor.getString(cursor.getColumnIndex(""eventLocation"")) : """")"	"                .put(""allDay"", cursor.getInt(cursor.getColumnIndex(""allDay"")))"	        );	      }	""	      PluginResult res = new PluginResult(PluginResult.Status.OK, result);	      callback.sendPluginResult(res);	      return true;	    } catch (JSONException e) {	"      System.err.println(""Exception: "" + e.getMessage());"	    }	    return false;	  }	""	  public void onActivityResult(int requestCode, int resultCode, Intent data) {	    if (requestCode == RESULT_CODE_CREATE) {	      if (resultCode == Activity.RESULT_OK || resultCode == Activity.RESULT_CANCELED) {	        // resultCode may be 0 (RESULT_CANCELED) even when it was created, so passing nothing is the clearest option here	        callback.success();	      }	    } else {	"      callback.error(""Unable to add event ("" + resultCode + "")."");"	    }	  }	}so from here, it shows into depth of the details. such as delete event. you have the start and end time, title and ocation. if the statement is true. finding events is the same. third gap. var argscheck = require('cordova/argscheck'),	    exec = require('cordova/exec'),	    ContactError = require('./ContactError'),	    utils = require('cordova/utils'),	    Contact = require('./Contact'),	    fieldType = require('./ContactFieldType');	    	""	/**	* Represents a group of Contacts.	* @constructor	*/	var contacts = {	    fieldType: fieldType,	    /**	     * Returns an array of Contacts matching the search criteria.	     * @param fields that should be searched	     * @param successCB success callback	     * @param errorCB error callback	     * @param {ContactFindOptions} options that can be applied to contact searching	     * @return array of Contacts matching search criteria	     */	    find:function(fields, successCB, errorCB, options) {	        argscheck.checkArgs('afFO', 'contacts.find', arguments);	        if (!fields.length) {	            errorCB && errorCB(new ContactError(ContactError.INVALID_ARGUMENT_ERROR));	        } else {	            // missing 'options' param means return all contacts	            options = options || {filter: '', multiple: true}	            var win = function(result) {	                var cs = [];	                for (var i = 0, l = result.length; i < l; i++) {	                    cs.push(contacts.create(result[i]));	                }	                successCB(cs);	            };	"            exec(win, errorCB, ""Contacts"", ""search"", [fields, options]);"	        }	    },	    	    /**	     * This function picks contact from phone using contact picker UI	     * @returns new Contact object	     */	    pickContact: function (successCB, errorCB) {	""	        argscheck.checkArgs('fF', 'contacts.pick', arguments);	""	        var win = function (result) {	            // if Contacts.pickContact return instance of Contact object	            // don't create new Contact object, use current	            var contact = result instanceof Contact ? result : contacts.create(result);	            successCB(contact);	        };	"        exec(win, errorCB, ""Contacts"", ""pickContact"", []);"	    },	""	    /**	     * This function creates a new contact, but it does not persist the contact	     * to device storage. To persist the contact to device storage, invoke	     * contact.save().	     * @param properties an object whose properties will be examined to create a new Contact	     * @returns new Contact object	     */	    create:function(properties) {	        argscheck.checkArgs('O', 'contacts.create', arguments);	        var contact = new Contact();	        for (var i in properties) {	            if (typeof contact[i] !== 'undefined' && properties.hasOwnProperty(i)) {	                contact[i] = properties[i];	            }	        }	        return contact;	    }	};	""	module.exports = contacts;so the variable is connected to contacts under a catigory of feild type. which returns an array of contact matching the search. the missing options “param” means to return all cntacts, list the feild that shoudl be searched, successCB success callback, error CB error callback. The fuction picks the contact from the phone. if the contact.pickcontact return instance of contact object, it wont create a new contact and use the current. the last chunk of code creates the new contact. the first plug in will serve as a notifcation for the second plug in as the calandar. it will remind the student/parent when the next tutoring session is coming up. the contacts will serve as a way to communicate with the tutor to the parent or student. 